{"version":3,"sources":["webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/webpack/bootstrap","webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/./js/navcam/AreaCam.js","webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/./js/navcam/NavCam.js","webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/./js/navcam/Path.js","webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/./js/navcam/lib/astar.js","webpack://if(typeof V3d === \"undefined\"){V3d = {};}if(typeof V3d.Navigation === \"undefined\")V3d.Navigation={};V3d.Navigation.NavCam/./js/navcam/lib/simplify.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,0G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,e;AACA;AACA;AACA;AACA;AACA,mBAEA;AACA,qCAgBA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kFAAkF;AAClF,kBAAkB;AAClB;AACA;AACA,8BAA8B;AAC9B,2CAA2C;AAC3C,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,WAAW;AACjC,0BAA0B,WAAW;AACrC,2CAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,yB;;;;;;;;;;;;AC3RA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2B;;;;;;;;;;;;ACpDA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kDAAkD,gBAAgB;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E,cAAc;;AAE7F;AACA;;AAEA,8DAA8D,uEAAuE;AACrI;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,iBAAiB;AAClE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sB;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6B;;;;;;;;;;;ACvZA;AACA;AACA;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,UAAU;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAmE,iBAAiB,EAAE;AAAA;AACtF,OAIA;;AAEA,CAAC","file":"V3d.Navigation.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./js/navcam/NavCam.js\");\n","class AreaCam {\r\n    constructor(params){\r\n\r\n        // OrthographicCamera( left, right, top, bottom, near, far )\r\n        this.camera = new THREE.OrthographicCamera();\r\n        this.camera.name = 'AreaCam_camera';\r\n\r\n        this.params = params || {};\r\n        if(this.params.resolution === undefined) this.params.resolution = new THREE.Vector2(64, 64);\r\n        if(this.params.growth === undefined) this.params.growth = 1;\r\n        if(this.params.wiggle === undefined) this.params.wiggle = .05;\r\n        if(this.params.overrideMaterial === undefined) this.params.overrideMaterial = AreaCam.defaultMaterial;\r\n        if(this.params.scene !== undefined) this.scene = this.params.scene;\r\n        console.log(this.params.resolution, this.scene, this.params.overrideMaterial);\r\n\r\n        this.renderer = new THREE.WebGLRenderer({\r\n            preserveDrawingBuffer:true\r\n        });\r\n        this.renderer.autoClear = false;\r\n        this.renderer.setSize(this.params.resolution.x, this.params.resolution.y);\r\n        this.renderer.setClearColor(new THREE.Color(0x000000), 1);\r\n\r\n        this.readFormat = THREE.RGBAFormat;\r\n        this.readBuffer = new Uint8Array(this.params.resolution.x * this.params.resolution.y * 4);\r\n        this.rtTexture = new THREE.WebGLRenderTarget(this.params.resolution.x, this.params.resolution.y, { \r\n                minFilter: THREE.NearestFilter, \r\n                magFilter: THREE.NearestFilter, \r\n                format: this.readFormat, \r\n                type: THREE.UnsignedByteType \r\n            }\r\n        );\r\n    }\r\n\r\n    get debugView(){\r\n        if(this._debugView === undefined) {\r\n            this._debugView = new THREE.Object3D();\r\n            this._debugView.name = 'AreaCam_debug';\r\n        }\r\n        return this._debugView;\r\n    }\r\n\r\n    SetRegion(left, right, top, bottom, low, high, direction, x, z){\r\n        if(left !== undefined) this.camera.left = left;\r\n        if(right !== undefined) this.camera.right = right;\r\n        if(top !== undefined) this.camera.top = top;\r\n        if(bottom !== undefined) this.camera.bottom = bottom;\r\n\r\n        if(this.camera.left !== undefined && this.camera.right !== undefined && this.camera.top !== undefined && this.camera.bottom !== undefined){\r\n            this.areaRatio = this.params.resolution.clone().divide(new THREE.Vector2(this.camera.right - this.camera.left, this.camera.top - this.camera.bottom));\r\n        }\r\n        \r\n        if(low !== undefined && high !== undefined){\r\n            this.low = low;\r\n            this.high = high;\r\n\r\n            this.camera.near = 0;\r\n            this.camera.far = this.high - this.low;\r\n        }\r\n\r\n        if(direction !== undefined){\r\n            this.direction = direction;\r\n            this.camera.position.copy(this.direction.clone().normalize().multiplyScalar(-this.high));\r\n            //this.camera.rotation.set(direction.x, direction.y, direction.z);\r\n            this.camera.rotation.copy(new THREE.Euler().setFromRotationMatrix(\r\n                new THREE.Matrix4().lookAt(this.camera.position, new THREE.Vector3(), new THREE.Vector3(0, 1, 0))\r\n            ));\r\n        }\r\n\r\n        if(x !== undefined) this.camera.position.x = x;\r\n        if(z !== undefined) this.camera.position.z = z;\r\n\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this.Snapshot();\r\n    }\r\n\r\n    Snapshot(){ \r\n        this.scene.overrideMaterial = this.params.overrideMaterial;\r\n        this.renderer.clearColor();\r\n        var rOffset = this.params.wiggle;\r\n        //console.log(\"Performance capabilities strategy selection\");\r\n        if(false){\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n        }\r\n        else if(false){ // Low end\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            var rx = this.camera.rotation.x;\r\n            var ry = this.camera.rotation.y;\r\n\r\n            this.camera.rotation.x = rx + rOffset;\r\n            this.camera.rotation.y = ry + rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            this.camera.rotation.x = rx - rOffset;\r\n            this.camera.rotation.y = ry - rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n            \r\n            this.camera.rotation.x = rx;\r\n            this.camera.rotation.y = ry;\r\n        }\r\n        else{ // high end\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            var rx = this.camera.rotation.x;\r\n            var ry = this.camera.rotation.y;\r\n\r\n            this.camera.rotation.x = rx + rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n            \r\n            this.camera.rotation.x = rx - rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            this.camera.rotation.x = rx;\r\n\r\n            this.camera.rotation.y = ry - rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            this.camera.rotation.y = ry + rOffset;\r\n            this.renderer.render(this.scene, this.camera, this.rtTexture, false);\r\n\r\n            this.camera.rotation.y = ry;\r\n        }\r\n        this.scene.overrideMaterial = null;\r\n        \r\n        this.renderer.readRenderTargetPixels(this.rtTexture, 0, 0, this.params.resolution.x, this.params.resolution.y, this.readBuffer);\r\n        \r\n        if(this.params.debug){\r\n            this.Helper(true);\r\n            this.DebugTexture(true);\r\n        }\r\n    }\r\n\r\n    CreateTextureFromBuffer(){\r\n        var texture = new THREE.DataTexture(this.readBuffer, this.params.resolution.x, this.params.resolution.y, this.readFormat);\r\n        texture.needsUpdate = true;\r\n        return texture;\r\n    }\r\n\r\n    Uint8ToGraph(graphArray){\r\n        var w = this.params.resolution.x,\r\n            h = this.params.resolution.y;\r\n        if(graphArray === undefined) graphArray = AreaCam.GraphArray(w, h);\r\n        graphArray = AreaCam.Uint8ToGraph(this.readBuffer, w, h, graphArray, this.params.growth);\r\n        return graphArray;\r\n    }\r\n\r\n    Helper(value){\r\n        if(value){\r\n            if(this._helper === undefined){\r\n                this._helper = new THREE.CameraHelper(this.camera);\r\n                this._helper.name = 'AreaCam_helper';\r\n                this.debugView.add(this._helper);\r\n            }\r\n            this._helper.visible = true;\r\n        }\r\n        else if(this._helper !== undefined){\r\n            this._helper.visible = false;\r\n        }\r\n    }\r\n\r\n    DebugTexture(value){\r\n        if(value){\r\n            if(this._debugTexture === undefined){\r\n                this._debugTexture = new THREE.Mesh(\r\n                    new THREE.BoxGeometry(this.camera.right - this.camera.left, .1, this.camera.top - this.camera.bottom)\r\n                );\r\n                this._debugTexture.name = 'AreaCam_debugTexture';\r\n                this.debugView.add(this._debugTexture);\r\n                this._debugTexture.position.set(0, 0, 20);\r\n            }\r\n            this._debugTexture.material.map = this.CreateTextureFromBuffer();\r\n            this._debugTexture.visible = true;\r\n        }\r\n        else if(this._debugTexture !== undefined){\r\n            this._debugTexture.visible = false;\r\n        }\r\n    }\r\n\r\n    static get defaultMaterial(){\r\n        if(this._defaultMaterial === undefined){\r\n            //var vertex = document.getElementById('vertexShader').textContent;\r\n            //var fragment = document.getElementById('fragmentShader').textContent;\r\n            var vertex = [\r\n                'void main() {',\r\n\t\t\t\t    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n                '}'\r\n            ].join('\\n');\r\n            var fragment = [\r\n                'void main() {',\r\n\t\t\t\t    'gl_FragColor = vec4(1, 1, 1, 1.0);',\r\n                '}'\r\n            ].join('\\n');\r\n            this._defaultMaterial = new THREE.ShaderMaterial({\r\n                name: 'NavCam.AreaCam.defaultMaterial',\r\n                vertexShader: vertex,\r\n                fragmentShader: fragment,\r\n                side: THREE.DoubleSide,\r\n                depthWrite: false,\r\n                lights: false\r\n            });\r\n        }\r\n        return this._defaultMaterial;\r\n    }\r\n\r\n    static GraphArray(w, h){\r\n        var array = [];\r\n        for(var x = 0; x < w; x++){\r\n            var row = [];\r\n            array.push(row);\r\n            for(var y = 0; y < h; y++){\r\n                row.push(0);\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n    static Uint8ToGraph(data, w, h, graphArray, growth){\r\n        var wLess = w - 1;\r\n        var hLess = h - 1;\r\n\r\n        for(var x = 1; x < wLess; x++){\r\n            for(var y = 1; y < hLess; y++){\r\n                if(false){ //regular\r\n                    var dataIndex = (y * w + x) * 4; //regular\r\n                    graphArray[x][y] = data[dataIndex] < 2 ? 1 : 0; //regular\r\n                }\r\n                else{\r\n                    // cross neighbours\r\n                    var valueCeil = 2;\r\n                    var any = (data[(y * w + x) * 4] > valueCeil);\r\n\r\n                    if(growth >= 1){\r\n                        any = any || ( \r\n                            (data[((y - 1) * w + x) * 4] > valueCeil)\r\n                            || (data[((y + 1) * w + x) * 4] > valueCeil)\r\n                            || (data[(y * w + x - 1) * 4] > valueCeil)\r\n                            || (data[(y * w + x + 1) * 4] > valueCeil)\r\n                        );\r\n                    }\r\n                    \r\n                    if(growth > 1){\r\n                        any = any || ( \r\n                            (data[((y - 2) * w + x) * 4] > valueCeil)\r\n                            || (data[((y + 2) * w + x) * 4] > valueCeil)\r\n                            || (data[(y * w + x - 2) * 4] > valueCeil)\r\n                            || (data[(y * w + x + 2) * 4] > valueCeil)\r\n                        );\r\n                    }\r\n\r\n                    if(growth > 2){\r\n                        any = any || ( \r\n                            (data[((y - 3) * w + x) * 4] > valueCeil)\r\n                            || (data[((y + 3) * w + x) * 4] > valueCeil)\r\n                            || (data[(y * w + x - 3) * 4] > valueCeil)\r\n                            || (data[(y * w + x + 3) * 4] > valueCeil)\r\n\r\n                            || (data[((y - 2) * w + x - 2) * 4] > valueCeil)\r\n                            || (data[((y - 2) * w + x + 2) * 4] > valueCeil)\r\n                            || (data[((y + 2) * w + x - 2) * 4] > valueCeil)\r\n                            || (data[((y + 2) * w + x + 2) * 4] > valueCeil)\r\n                        );\r\n                    }\r\n\r\n                    graphArray[x][y] = any ? 0 : 1;\r\n                }\r\n            }\r\n        }\r\n        return graphArray;\r\n    }\r\n\r\n    static MergeVertices(obj){\r\n        obj.traverse(function(child){\r\n            if(child instanceof THREE.Mesh){\r\n\t\t\t\tvar tempGeo = new THREE.Geometry().fromBufferGeometry(child.geometry);\r\n\t\t\t\ttempGeo.mergeVertices();\r\n\t\t\t\ttempGeo.computeVertexNormals();\r\n\t\t\t\ttempGeo.computeFaceNormals();\r\n\t\t\t\tchild.geometry = new THREE.BufferGeometry().fromGeometry(tempGeo);\r\n            }\r\n\t\t});\r\n    }\r\n}\r\n\r\nmodule.exports = AreaCam;","\r\nconst AreaCam = require('./AreaCam');\r\nconst Path = require('./Path');\r\n\r\nclass NavCam{\r\n\r\n    constructor(params){\r\n\r\n        this.areaCam = new AreaCam({\r\n            resolution: params.resolution,\r\n            growth: params.growth,\r\n            wiggle: params.wiggle,\r\n            overrideMaterial: params.overrideMaterial,\r\n            scene: params.scene,\r\n            debug: params.debug\r\n        });\r\n\r\n        this.pathfinder = new Path(this.areaCam, {\r\n            arcLengthDivisions: params.arcLengthDivisions,\r\n            smoothPath: params.smoothPath,\r\n            tryGetRange: params.tryGetRange,\r\n            debug: params.debug\r\n        });\r\n    }\r\n\r\n    Update(){\r\n\r\n        this.Snapshot();\r\n    }\r\n\r\n    Snapshot(){\r\n        if(this.areaCam.params.debug) this.areaCam.debugView.visible = false;\r\n        if(this.pathfinder.params.debug) this.pathfinder.debugView.visible = false;\r\n        // Render with override material\r\n        this.areaCam.Snapshot();\r\n\r\n        if(this.areaCam.params.debug) this.areaCam.debugView.visible = true;\r\n        if(this.pathfinder.params.debug) this.pathfinder.debugView.visible = true;\r\n        \r\n        // [0, 1] walkable/wall array\r\n        this.graphArray = this.areaCam.Uint8ToGraph(this.graphArray);\r\n    }\r\n\r\n    Solve(worldStart, worldEnd, inserts){\r\n        this.Snapshot();\r\n        var worldPath = this.pathfinder.Solve(worldStart, worldEnd, this.graphArray, inserts);\r\n        return worldPath;\r\n    }\r\n\r\n}\r\n\r\nmodule.exports = NavCam;\r\nmodule.exports.AreaCam = AreaCam;\r\nmodule.exports.Path = Path;","\r\nconst astar = require('./lib/astar');\r\nconst simplify = require('./lib/simplify');\r\n\r\nvar _gridResult, _graph, _graphStart, _options;\r\n\r\nclass Path{\r\n    constructor(areaCam, params){\r\n        this.areaCam = areaCam;\r\n\r\n        this.params = params || {debug:false};\r\n        if(this.params.arcLengthDivisions === undefined) this.params.arcLengthDivisions = 100;\r\n        if(this.params.smoothPath === undefined) this.params.smoothPath = 2;\r\n        if(this.params.tryGetRange === undefined) this.params.tryGetRange = 0;\r\n    }\r\n\r\n    get debugView(){\r\n        if(this._debugView === undefined) {\r\n            this._debugView = new THREE.Object3D();\r\n            this._debugView.name = 'NavPath_debug';\r\n        }\r\n        return this._debugView;\r\n    }\r\n\r\n    ToGrid(world){\r\n        var cam = this.areaCam.camera;\r\n        var toCamX = cam.position.x - world.x,\r\n            toCamY = cam.position.z - world.z;\r\n        var gridX = (toCamX - cam.left) * this.areaCam.areaRatio.x,\r\n            gridY = (toCamY - cam.bottom) * this.areaCam.areaRatio.y;\r\n        gridX = THREE.Math.clamp(this.areaCam.params.resolution.x - Math.floor(gridX + .001), 0, this.areaCam.params.resolution.x - 1);\r\n        gridY = THREE.Math.clamp(Math.floor(gridY + .001), 0, this.areaCam.params.resolution.y - 1);\r\n        return new THREE.Vector2(gridX, gridY);\r\n    }\r\n\r\n    ToWorld(grid){\r\n        var cam = this.areaCam.camera;\r\n        var toCamX = grid.x / this.areaCam.areaRatio.x + cam.left;\r\n        var toCamY = (this.areaCam.params.resolution.y - grid.y) / this.areaCam.areaRatio.y + cam.bottom;\r\n        var worldX = toCamX + cam.position.x;\r\n        var worldZ = toCamY + cam.position.z;\r\n        return new THREE.Vector3(worldX, 0, worldZ);\r\n    }\r\n\r\n    Simplify(points, tolerance){\r\n        if(tolerance === undefined) tolerance = 2.;\r\n        var highQuality = true;\r\n        var simplified = simplify(points, tolerance, highQuality);\r\n\r\n        if(this.params.debug){\r\n            //console.log('\\tSimplified path:', points);\r\n        }\r\n\r\n        // Raycast check clear from point to point, remove unecessary points\r\n\r\n        return simplified;\r\n    }\r\n\r\n    ToWorldResult(result){\r\n        var worldResult = [];\r\n\r\n        for(var i = 0, numResults = result.length; i < numResults; i++){\r\n            var worldPos = this.ToWorld(result[i]);\r\n            worldResult[i] = worldPos;\r\n        }\r\n\r\n        return worldResult;\r\n    }\r\n\r\n    Closest(graph, pt, testNode){\r\n        var grid = graph.grid;\r\n        var w = grid.length;\r\n        if(w < 3 || grid[0].length < 3) return undefined;\r\n        var h = grid[0].length;\r\n\r\n        var x = THREE.Math.clamp(pt.x, 0, w - 1);\r\n        var y = THREE.Math.clamp(pt.y, 0, h - 1);\r\n\r\n        if(testNode(grid[x][y])) return grid[x][y];\r\n\r\n        for(var iExpand = 1, numExpand = this.params.tryGetRange; iExpand < numExpand; iExpand++){\r\n            var left = THREE.Math.clamp(x - iExpand, 0, w - 1),\r\n                right = THREE.Math.clamp(x + iExpand + 1, left, w - 1),\r\n                bottom = THREE.Math.clamp(y - iExpand, 0, h - 1),\r\n                top = THREE.Math.clamp(y + iExpand + 1, bottom, h - 1);\r\n            for(var iX = left; iX < right; iX ++){\r\n                var skipY = iX === left || iX === right ? 1 : THREE.Math.clamp(top - bottom - 2, 1, iExpand * 2);\r\n                for(var iY = bottom; iY < top; iY += skipY){\r\n                    if(testNode(grid[iX][iY])){\r\n                        return grid[iX][iY];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    _ClosestDefaultTest(node){\r\n        return !node.isWall()\r\n    }\r\n\r\n    _ClosestSearchTest(node){\r\n        var notWall = !node.isWall();\r\n        if(notWall) _gridResult = astar.search(_graph, _graphStart, node, _options);\r\n        return _gridResult !== undefined && _gridResult.length > 1;\r\n    }\r\n\r\n    Search(graph, start, end, options){\r\n\r\n        var graphStart = this.Closest(graph, start, this._ClosestDefaultTest);\r\n        if(graphStart !== undefined){\r\n            _gridResult = undefined;\r\n            _graph = graph;\r\n            _graphStart = graphStart;\r\n            _options = options;\r\n            if(this.params.tryGetRange > 0){\r\n                this.Closest(graph, end, this._ClosestSearchTest);\r\n            }\r\n            else{\r\n                var graphEnd = this.Closest(graph, end, this._ClosestDefaultTest);\r\n                if(graphEnd !== undefined) _gridResult = astar.search(_graph, _graphStart, graphEnd, _options);\r\n            }\r\n\r\n            if(_gridResult !== undefined && _gridResult.length > 1) return _gridResult;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    Solve(worldStart, worldEnd, graphArray, inserts){\r\n        if(graphArray !== undefined) this.graph = new astar.Graph(graphArray, {diagonal:true});\r\n\r\n        var start = this.ToGrid(worldStart),\r\n            end = this.ToGrid(worldEnd);\r\n\r\n        var gridResult = this.Search(this.graph, start, end, {heuristic:astar.heuristics.euclideanPreferStraight, diagonalWeight:1.3});\r\n        if(gridResult !== undefined){\r\n            var worldY = (worldStart.y + worldEnd.y) * .5;\r\n            var worldResult = this.ToWorldResult(this.Simplify(gridResult, this.params.smoothPath), worldY);\r\n            \r\n            // inserts\r\n            if(inserts !== undefined){\r\n                for(var i = 0; i < inserts.length; i++){\r\n                    var insert = inserts[i];\r\n                    insert.position.y = 0;\r\n                    worldResult.splice(insert.index, 0, insert.position);\r\n                }\r\n            }\r\n\r\n            // interpolate y\r\n            var dy = worldEnd.y - worldStart.y;\r\n            for(var i = 0, numResults = worldResult.length; i < numResults; i++) worldResult[i].y = worldStart.y + dy * (i / numResults);\r\n            if(worldResult !== undefined && worldResult.length > 1){\r\n                worldResult[0] = worldStart;\r\n                this.UpdateCurve(worldResult);\r\n                \r\n                if(this.params.debug){\r\n                    var gridTexture = this.CreateTextureFromGrid(graphArray, start, end, gridResult);\r\n                    this.DebugTexture(gridTexture);\r\n                }\r\n\r\n                return this.curve;\r\n            }\r\n        }\r\n\r\n        if(this.curve !== undefined) this.UpdateCurve();\r\n        return undefined;\r\n    }\r\n\r\n    UpdateCurve(positions){\r\n        \r\n        if(this.curve === undefined){\r\n            this.curve = new THREE.CatmullRomCurve3(positions);\r\n            this.curve.arcLengthDivisions = this.params.arcLengthDivisions;\r\n            this.curve.type = 'centripetal';\r\n            this.curve.tension = .5;\r\n\r\n            this._tempCurvePoint = new THREE.Vector3();\r\n\r\n            if(this.params.debug){\r\n                var geometry = new THREE.Geometry();\r\n                for (var i = 0; i < this.curve.arcLengthDivisions; i++){\r\n                    geometry.vertices.push(new THREE.Vector3());\r\n                }\r\n            \r\n                this.curve.mesh = new THREE.Line(geometry, \r\n                    new THREE.LineBasicMaterial({\r\n                        color: 0x0000ff,\r\n                        linewidth: 10\r\n                    })\r\n                );\r\n                this.curve.mesh.name = 'NavPath_path';\r\n\r\n                this.debugView.add(this.curve.mesh);\r\n            }\r\n        }\r\n\r\n        if(positions === undefined){\r\n            if(this._clearCurvePositions === undefined) this._clearCurvePositions = [new THREE.Vector3(), new THREE.Vector3()];\r\n            this.curve.points = this._clearCurvePositions;\r\n        }\r\n        else{\r\n            this.curve.points = positions;\r\n        }\r\n        this.curve.needsUpdate = true;\r\n\r\n        if(this.params.debug && this.curve !== undefined){\r\n            var divisions = this.curve.arcLengthDivisions;\r\n            for (var i = 0; i < divisions; i ++){\r\n                var p = this.curve.mesh.geometry.vertices[i];\r\n                p.copy(this.curve.getPoint(i / (divisions - 1)));\r\n            }\r\n            this.curve.mesh.geometry.verticesNeedUpdate = true;\r\n        }\r\n    }\r\n\r\n    GetAt(time){\r\n        if(this.curve !== undefined){\r\n            time = THREE.Math.clamp(time > 1 ? time % 1 : time, 0, 1);\r\n            var point = this.curve.getPoint(time, this._tempCurvePoint);\r\n            return point !== undefined ? point : undefined;\r\n        }\r\n    }\r\n\r\n    CreateTextureFromGrid(grid, start, end, path){\r\n        var w = this.areaCam.params.resolution.x,\r\n            h = this.areaCam.params.resolution.y;\r\n        var readBuffer = new Uint8Array(w * h * 4);\r\n        for(var x = 0; x < w; x++){\r\n            for(var y = 0; y < h; y++){\r\n                var index = (y * w + x) * 4;\r\n                var on = readBuffer[index] = grid[x][y] * 255;\r\n                readBuffer[index + 1] = on;\r\n                readBuffer[index + 2] = on;\r\n\r\n                readBuffer[index + 3] = 255;\r\n            }\r\n        }\r\n\r\n        var setPoint = function(v, r, g, b){\r\n            var index = (v.y * w + v.x) * 4;\r\n            readBuffer[index] = r;\r\n            readBuffer[index + 1] = g;\r\n            readBuffer[index + 2] = b;\r\n        };\r\n\r\n        for(var iPath = 0, numPath = path.length; iPath < numPath; iPath++){\r\n            setPoint(path[iPath], 0, 255, 255);\r\n        }\r\n\r\n        setPoint(start, 100, 255, 100);\r\n        setPoint(end, 100, 100, 255);\r\n\r\n        var texture = new THREE.DataTexture(readBuffer, w, h, THREE.RGBAFormat);\r\n        texture.needsUpdate = true;\r\n        return texture;\r\n    }\r\n\r\n    DebugTexture(map){\r\n        if(map){\r\n            if(this._debugTexture === undefined){\r\n                var cam = this.areaCam.camera;\r\n                this._debugTexture = new THREE.Mesh(\r\n                    new THREE.BoxGeometry(cam.right - cam.left, .1, cam.top - cam.bottom)\r\n                );\r\n                this._debugTexture.name = 'NavPath_debugTexture';\r\n                this.debugView.add(this._debugTexture);\r\n                this._debugTexture.position.set(-20, 0, 20);\r\n            }\r\n            this._debugTexture.material.map = map;\r\n            this._debugTexture.visible = true;\r\n        }\r\n        else if(this._debugTexture !== undefined){\r\n            this._debugTexture.visible = false;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Path;","// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node;\n  var path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function(node) {\n    return node.f;\n  });\n}\n\nvar astar = {\n  /**\n  * Perform an A* Search on a graph given a start and end node.\n  * @param {Graph} graph\n  * @param {GridNode} start\n  * @param {GridNode} end\n  * @param {Object} [options]\n  * @param {bool} [options.closest] Specifies whether to return the\n             path to the closest node if the target is unreachable.\n  * @param {Function} [options.heuristic] Heuristic function (see\n  *          astar.heuristics).\n  */\n  search: function(graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan;\n    var diagonalWeight = options.diagonalWeight || 1.41421;\n    var closest = options.closest || false;\n\n    var openHeap = getHeap(),\n        closestNode = start; // set the start node to be the closest if required\n    var closedList = [];\n    start.h = heuristic(start, end, start);\n\n    openHeap.push(start);\n\n    while(openHeap.size() > 0) {\n\n        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n        var currentNode = openHeap.pop();\n\n        // End case -- result has been found, return the traced path.\n        if(currentNode === end) {\n            while(closedList.length>0)closedList.pop().closed = false;\n            return pathTo(currentNode);\n        }\n\n        // Normal case -- move currentNode from open to closed, process each of its neighbors.\n        currentNode.closed = true;\n        closedList.push(currentNode);\n\n        // Find all neighbors for the current node.\n        var neighbors = graph.neighbors(currentNode);\n\n        for (var i = 0, il = neighbors.length; i < il; ++i) {\n            var neighbor = neighbors[i];\n\n            if (neighbor.closed || neighbor.isWall()) {\n                // Not a valid node to process, skip to next neighbor.\n                continue;\n            }\n\n            // The g score is the shortest distance from start to current node.\n            // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n            var gScore = currentNode.g + neighbor.getCost(currentNode, diagonalWeight),\n                beenVisited = neighbor.visited;\n\n            if (!beenVisited || gScore < neighbor.g) {\n\n                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                neighbor.visited = true;\n                neighbor.parent = currentNode;\n                neighbor.h = neighbor.h || heuristic(neighbor, end, currentNode);\n                neighbor.g = gScore;\n                neighbor.f = neighbor.g + neighbor.h;\n                graph.markDirty(neighbor);\n                if (closest) {\n                    // If the neighbour is closer than the current closestNode or if it's equally close but has\n                    // a cheaper path than the current closest node then it becomes the closest node\n                    if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n                        closestNode = neighbor;\n                    }\n                }\n\n                if (!beenVisited) {\n                    // Pushing to heap will put it in proper place based on the 'f' value.\n                    openHeap.push(neighbor);\n                }\n                else {\n                    // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                    openHeap.rescoreElement(neighbor);\n                }\n            }\n        }\n    }\n    while(closedList.length>0)closedList.pop().closed = false;\n\n    if (closest) {\n        return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n      manhattan: function(pos0, pos1) {\n          var d1 = Math.abs(pos1.x - pos0.x);\n          var d2 = Math.abs(pos1.y - pos0.y);\n          return d1 + d2;\n      },\n      diagonal: function(pos0, pos1) {\n          var D = 1;\n          var D2 = Math.sqrt(2);\n          var d1 = Math.abs(pos1.x - pos0.x);\n          var d2 = Math.abs(pos1.y - pos0.y);\n          return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n      },\n      euclidean: function(pos0, pos1) {\n        var dx = pos1.x - pos0.x,\n          dy = pos1.y - pos0.y;\n        return Math.sqrt(dx * dx + dy * dy);\n      },\n      euclideanPreferStraight: function(pos0, pos1, current){\n        var dx2 = pos0.x - pos1.x,\n            dy2 = pos0.y - pos1.y;\n\n        var dx1 = current.x - pos1.x,\n            dy1 = current.y - pos1.y;\n\n        var cross = Math.abs(dx1 * dy2 - dx2 * dy1)\n        var heuristic = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        return heuristic + cross * 0.01;\n      }\n  },\n  cleanNode:function(node){\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n  }\n};\n\n/**\n * A graph memory structure\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options]\n * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function() {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function() {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function(node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function(node) {\n  var ret = [];\n  var x = node.x;\n  var y = node.y;\n  var grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function() {\n  var graphString = [];\n  var nodes = this.grid;\n  for (var x = 0; x < nodes.length; x++) {\n    var rowDebug = [];\n    var row = nodes[x];\n    for (var y = 0; y < row.length; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function(fromNeighbor, diagonalWeight) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {\n    return this.weight * diagonalWeight;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function(node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function() {\n    return this.content.length;\n  },\n  rescoreElement: function(node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function(n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1;\n      var parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      }\n      // Found a parent that is less, no need to sink any further.\n      else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function(n) {\n    // Look up the target element and its score.\n    var length = this.content.length;\n    var element = this.content[n];\n    var elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1;\n      var child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null;\n      var child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N];\n        var child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = astar;\nmodule.exports.Graph = Graph;","/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n(function () { 'use strict';\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nif (typeof define === 'function' && define.amd) define(function() { return simplify; });\nelse if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n} else if (typeof self !== 'undefined') self.simplify = simplify;\nelse window.simplify = simplify;\n\n})();\n"],"sourceRoot":""}